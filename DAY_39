# 3508. Implement Router 

#include <bits/stdc++.h>
using namespace std;

struct Triple {
    int s, d, t;
    bool operator==(const Triple &o) const {
        return s == o.s && d == o.d && t == o.t;
    }
};

struct TripleHash {
    size_t operator()(Triple const& k) const noexcept {
        // simple mix using 64-bit arithmetic
        uint64_t x = (uint64_t)k.s;
        uint64_t y = (uint64_t)k.d;
        uint64_t z = (uint64_t)k.t;
        uint64_t h = x * 1000003ULL + y;
        h = h * 1000000009ULL + z;
        return (size_t)(h ^ (h >> 32));
    }
};

class Router {
private:
    int capacity;
    deque<Triple> q; // FIFO store of packets
    unordered_set<Triple, TripleHash> seen; // current packets (to detect duplicates)
    unordered_map<int, deque<int>> destMap; // destination -> sorted deque of timestamps

public:
    Router(int memoryLimit) : capacity(memoryLimit) {
        seen.reserve(memoryLimit * 2 + 10);
        destMap.reserve(1024);
    }
    
    bool addPacket(int source, int destination, int timestamp) {
        Triple key{source, destination, timestamp};
        if (seen.find(key) != seen.end()) return false; // duplicate present
        
        // Insert new packet
        q.push_back(key);
        seen.insert(key);
        destMap[destination].push_back(timestamp); // timestamps are non-decreasing
        
        // Evict oldest if capacity exceeded
        if ((int)q.size() > capacity) {
            Triple old = q.front(); q.pop_front();
            seen.erase(old);
            auto &dq = destMap[old.d];
            if (!dq.empty() && dq.front() == old.t) {
                dq.pop_front();
            } else {
                // fallback: find and remove first occurrence (shouldn't normally happen)
                auto it = std::find(dq.begin(), dq.end(), old.t);
                if (it != dq.end()) dq.erase(it);
            }
            if (dq.empty()) destMap.erase(old.d);
        }
        return true;
    }
    
    vector<int> forwardPacket() {
        if (q.empty()) return {};
        Triple p = q.front(); q.pop_front();
        seen.erase(p);
        auto &dq = destMap[p.d];
        if (!dq.empty() && dq.front() == p.t) {
            dq.pop_front();
        } else {
            auto it = std::find(dq.begin(), dq.end(), p.t);
            if (it != dq.end()) dq.erase(it);
        }
        if (dq.empty()) destMap.erase(p.d);
        return {p.s, p.d, p.t};
    }
    
    int getCount(int destination, int startTime, int endTime) {
        auto it = destMap.find(destination);
        if (it == destMap.end()) return 0;
        auto &dq = it->second;
        auto lb = lower_bound(dq.begin(), dq.end(), startTime);
        auto ub = upper_bound(dq.begin(), dq.end(), endTime);
        return static_cast<int>(ub - lb);
    }
};
